///   \file mixc.cc 
///   \brief Driver application for the compiler

#include <iostream>
#include <fstream>
#include <argp.h>

#include <mixal.hh>
#include <irgen.hh>
#include <llvm/System/Program.h>
#include <llvm/Bitcode/ReaderWriter.h>

int debug_lexer; /*!< Flag used to tell the lexer to go into debug mode */


static const char *doc                      = "mixc -- A compiler for MIX programs";   /*!< Overview documentation                 */
static const char *args_doc                 = "inputfile";                             /*!< Arguments overview documentation       */
       const char *argp_program_version     = "1.0";                                   /*!< Version number displayed in help       */
       const char *argp_program_bug_address = "matt@innerweaver.com";                  /*!< Maintainer address displayed in help   */



static const int argp_option_verbose       = 'v';   /*!< Verbose output */
static const int argp_option_debug_parser  = -101;  /*!< Debug the parser */
static const int argp_option_debug_lexer   = -102;  /*!< Debug the lexer */
static const int argp_option_debug_codegen = -103;  /*!< Debug code generation */
static const int argp_option_keep_bitcode  = -104;  /*!< Keep the generated bytecode */
static const int argp_option_inputfile     = 'i';   /*!< Input file     */
static const int argp_option_standardlib   = 's';   /*!< Name of standard library to link in */
static const int argp_option_libdir        = 'L';   /*!< Name of directory to link in from */
static const int argp_option_lib           = 'l';   /*!< Name of library to link in */
static const int argp_option_output        = 'o';   /*!< Name of the output file */
static const int argp_option_no_opt        = -105;  /*!< Disable optimizations */

/*!
 *  \brief  List of available options
 */
static struct argp_option options[] = {
	{ "verbose",      argp_option_verbose,           0, 0, "Produce verbose output" },
	{ "debugparser",  argp_option_debug_parser,      0, 0, "Debug the parser" },
	{ "debuglexer",   argp_option_debug_lexer,       0, 0, "Debug the lexer" },
	{ "debugcodegen", argp_option_debug_codegen,     0, 0, "Debug code generation" },
	{ "keepbitcode",  argp_option_keep_bitcode,      0, 0, "Keep the generated .i file" },
	{ "inputfile",    argp_option_inputfile,    "FILE", 0, "Compile from source FILE" },
	{ "standardlib",  argp_option_standardlib,   "LIB", 0, "Link in LIB as the standard lib" },
	{ "libdir",       argp_option_libdir,        "DIR", 0, "Look in DIR for libraries" },
	{ "lib",          argp_option_lib,           "LIB", 0, "Link in library LIB" },
	{ "output",       argp_option_output,       "FILE", 0, "Write output to FILE" },
	{ "no-opt",       argp_option_no_opt,            0, 0, "Disable optimizations" },
	{ 0 }
};

/*!
 *  \brief  Holder for argument values
 */
struct Arguments {
	
	/*!
	 *   \brief Default constructor
	 */
	Arguments() 
	: verbose(false),
	  debugParser(false),
	  debugLexer(false),
	  debugCodegen(false),
	  optimize(true),
	  inputFile(""),
	  standardLib("mixstdlib"),
	  output("")
	{
	}
	
	bool        verbose;      /*!< Whether to create verbose output     */
	bool        debugParser;  /*!< Whether to debug the parser          */
	bool        debugLexer;   /*!< Whether to debug the lexer           */
	bool        debugCodegen; /*!< Whether to debug code generator      */
	bool        keepBitcode;  /*!< Whether to keep the bytecode         */
	bool        optimize;     /*!< Whether to perform optimizations     */
	std::string inputFile;    /*!< Name of the source file to compile   */
	std::string standardLib;
	std::vector<std::string> libDir;
	std::vector<std::string> lib;
	std::string output;
};

/*!
 *   \brief Handle a single argument
 *
 *   Callback function used to handle arguments
 *
 *   \param   key    Key of the argument
 *   \param   arg    Argument value
 *   \param   state  Argument parser state
 */
static error_t parse_opt(int key, char *arg, struct argp_state *state) {
	Arguments *args = reinterpret_cast<Arguments *>(state->input);
	
	switch(key) {
	case argp_option_verbose:
		args->verbose = true;
		break;
		
	case argp_option_debug_parser:
		args->debugParser = true;
		break;

	case argp_option_debug_lexer:
		args->debugLexer = true;
		break;

	case argp_option_debug_codegen:
		args->debugCodegen = true;
		break;

	case argp_option_keep_bitcode:
		args->keepBitcode = true;
		break;

	case argp_option_inputfile:
		args->inputFile = strdup(arg);
		break;
		
	case argp_option_standardlib:
		args->standardLib = strdup(arg);
		break;

	case argp_option_libdir:
		args->libDir.push_back(strdup(arg));
		break;

	case argp_option_lib:
		args->lib.push_back(strdup(arg));
		break;

	case argp_option_output:
		args->output = strdup(arg);
		break;

	case argp_option_no_opt:
		args->optimize = false;
		break;

	case ARGP_KEY_ARG:
		if(state->arg_num >= 1) {
			argp_usage(state);
		}
		
		args->inputFile = strdup(arg);
		break;
		
	default:
		return ARGP_ERR_UNKNOWN;
	}
	
	return 0;
}

std::string replaceExtension(const std::string &filename, const std::string& ext) {
	return filename.substr(0, filename.rfind('.')).append(ext);
}

/*!
 *   \brief Application entry point
 *
 *   Main entry point for the application.  Parses arguments and delegates
 *   control to other parts of the application.
 */
int main(int argc, char **argv)
{
	Arguments args;
	args.verbose = false;
	struct argp argp = { options, parse_opt, args_doc, doc };
	
	/* Parse arguments */
	argp_parse(&argp, argc, argv, 0, 0, &args);
	
	/* Ensure we have an input file */
	if(args.inputFile.size() == 0) {
		std::cerr << "No input file specified" << std::endl;
		return -1;
	}
	
	if(args.output.size() == 0) {
		args.output = replaceExtension(args.inputFile, "");
	}

	if(args.verbose) {
		std::cout << "Compiling file '" << args.inputFile << "'" << std::endl;
	}

	if(args.debugLexer) {
		debug_lexer = 1;
	} else {
		debug_lexer = 0;
	}
	
	mixal::Program prog;
	mixal::IrGen irgen = mixal::IrGen(args.debugCodegen, args.inputFile);

	prog.debug = args.debugParser;

	/* Parse the program */
	try {
		mixal::Statement *stmt = prog.parse(args.inputFile);
		irgen.generate(stmt);

		std::ofstream bcOutput(replaceExtension(args.inputFile, ".bc").c_str(), std::ofstream::binary | std::ofstream::out | std::ofstream::trunc);
		llvm::WriteBitcodeToFile(irgen.module(), bcOutput);

		const char** ldArgs = new const char*[args.libDir.size() + args.lib.size() + (args.optimize ? 7 : 8)];
		int curLdArg = 0;
		ldArgs[curLdArg++] = "llvm-ld";
		ldArgs[curLdArg++] = strdup(("-o=" + args.output).c_str());
		ldArgs[curLdArg++] = "-native";
		if(!args.optimize) {
			ldArgs[curLdArg++] = "-disable-opt";
		}
		ldArgs[curLdArg++] = strdup(std::string("-l").append(args.standardLib).c_str());
		for(std::vector<std::string>::iterator it = args.libDir.begin(); it != args.libDir.end(); ++it) {
			ldArgs[curLdArg++] = strdup(std::string("-L").append(*it).c_str());
		}
		for(std::vector<std::string>::iterator it = args.lib.begin(); it != args.lib.end(); ++it) {
			ldArgs[curLdArg++] = strdup(std::string("-l").append(*it).c_str());
		}
		ldArgs[curLdArg++] = strdup(replaceExtension(args.inputFile, ".bc").c_str());
		ldArgs[curLdArg++] = NULL;

		if(args.verbose) {
			std::cout << "Linking: llvm-ld ";
			for(int i = 0; i < curLdArg; i++) {
				std::cout << "'" << ldArgs[i] << "' ";
			}
			std::cout << std::endl;
		}

		llvm::sys::Program::ExecuteAndWait(llvm::sys::Program::FindProgramByName("llvm-ld"), ldArgs);
	} catch(const char *msg) {
		std::cerr << msg << std::endl;
		return -1;
	} catch(std::string msg) {
		std::cerr << msg << std::endl;
		return -1;
	}

	return 0;
}
